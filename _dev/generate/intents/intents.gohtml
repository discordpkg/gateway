package intent

// Code generated - This file has been automatically generated by internal/generate/events/main.go - DO NOT EDIT.
// Warning: This file is overwritten at "go generate", instead adapt internal/constants/events.go and run go generate

import (
       "github.com/andersfylling/discordgateway/event"
       "github.com/andersfylling/discordgateway/internal/constants"
)

type Type constants.Intent

func (i Type) Events() []event.Type {
    return Events(i)
}

const (
{{- range .}}
    {{.}} = Type({{.Intent}})
{{- end}}
)

const All Type = {{range .}}{{.}} | {{- end}} 0

var intentsToEventsMap = map[Type][]event.Type{
{{- range .}}
    {{.}}: {{.Events}},
{{- end}}
}

var emptyStruct struct{}
var dmIntents = map[Type]struct{}{
{{- range .}}
{{- if .IsDM }}
    {{.}}: emptyStruct,
{{- end}}
{{- end}}
}

func Events(intent Type) []event.Type {
    if events, ok := intentsToEventsMap[intent]; ok {
        cpy := make([]event.Type, len(events))
        copy(cpy, events)
        return cpy
    }
    return nil
}

func Merge(intents ...Type) Type {
    var merged Type
    for i := range intents {
        merged |= intents[i]
    }
    return merged
}

func DMEventsToIntents(src []event.Type) Type {
    return eventsToIntents(src, true)
}

func GuildEventsToIntents(src []event.Type) Type {
    return eventsToIntents(src, false)
}

func eventsToIntents(src []event.Type, dm bool) (intents Type) {
    contains := func(haystack []event.Type, needle event.Type) bool {
        for i := range haystack {
            if haystack[i] == needle {
                return true
            }
        }
        return false
    }

    for i := range src {
        for intent, events := range intentsToEventsMap {
            if _, isDM := dmIntents[intent]; (!dm && isDM) || (dm && !isDM) {
                continue
            }
            if contains(events, src[i]) {
                intents |= intent
            }
        }
    }

    return intents
}
